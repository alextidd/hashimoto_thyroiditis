---
title: "First year report plots"
author: "Alexandra Tidd"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    fig_width: 8
    keep_md: true
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    theme: lumen
params:
  rerun: false
---

```{r setup, include = F, message = F, warning = F, echo = F}
# rmarkdown::render('reports/20250422_first_year_report_plots.Rmd', output_file = '20250422_first_year_report_plots.html', output_dir = 'reports')

# chunk options
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(warning = FALSE,
                      dpi = 300,
                      message = FALSE,
                      cache.path = "reports/20250422_first_year_report_plots_cache/")
```

```{r libraries, include = F, message = F, warning = F, echo = F}
# libraries
library(magrittr)
library(dplyr)
library(readr)
library(tidyr)
library(ggplot2)
library(patchwork)
library(GenomicRanges)
library(rtracklayer)
library(liftOver)
library(biomaRt)
source("bin/utils.R")

# celltype palette
pal <- c("B" = "#2f9e77",
         "mature B" = "#55c552", "activated B" = "#55c552",
         "non-mature B" = "#397037", "naive B" = "#397037",
         "other" = "#d95f02",
         "NK" = "#e72a8a", "Myeloid" = "#984ea3",
         "non-haematopoietic" = "#ff7f00", "T" = "#377eb8",
         "alpha-beta T cell" = "#377eb8", "B cell" = "#2f9e77",
         "mature B cell" = "#55c552", "not lymphocyte" = "#d95f02",
         "not mature B cell" = "#397037")

# dndscv palette
impact_colours <- c("Missense" = "#5f9fa0",
                    "Nonsense" = "#682c8b",
                    "Essential_Splice" = "#8e55a3",
                    "Indels" = "#d4773f",
                    "no-SNV" = "#d4773f",
                    "Synonymous" = "#b3b4b4",
                    "Non-coding" = "#606060")
```

# Samplesheet

```{r load_ss}
man_insp <-
  read_tsv("data/manual_inspection/2024-12-20_PD63118_PTA_BAF_LoH_CellType_Mut_Summary.tsv") %>%
  dplyr::select(-run_id) %>%
  # fix loh_1p
  mutate(loh_1p = as.character(as.numeric(loh_1p)))
ss <-
  read_csv("data/resolveome/samplesheet_local.csv") %>%
  # add manual inspection data
  left_join(man_insp)
driver_genes <-
  readLines("../trencadis-seq/data/thyroid/driver_genes/driver_genes.txt")
```

# Quality control

We determine which cells to keep. QC has been completed for plate 3, but has not
been completed for plate 10, as only DNAhyb data is available for these cells,
so it is more difficult to definitively call doublets and chromosomal dropouts.
However, based on the new gating strategy for flow cytometry and based on the
pre-PCR quants, we can be fairly confident that the cells are of high quality,
so we will include all plate 10 cells in the analysis.

```{r qc}
# counts
n_seq_cells <- n_distinct(ss$cell_id)
n_seq_dnahyb_cells <- ss %>% filter(seq_type == "dnahyb") %>% {n_distinct(.$cell_id)}
n_seq_dna_cells <- ss %>% filter(seq_type == "dna") %>% {n_distinct(.$cell_id)}

# qc-passing cells
ss_pass <-
  ss %>%
  filter((plate == 3 & !suspected_doublet & !chr_dropout) |
         (plate == 10 &
          (is.na(suspected_doublet) | !suspected_doublet) &
          (is.na(chr_dropout) | !chr_dropout)))
n_pass_cells <- n_distinct(ss_pass$cell_id)
```

Of 263 isolated nuclei, `r n_seq_cells` passed pre-PCR quantification QC
and were submitted for sequencing. `r n_seq_dnahyb_cells` cells underwent 
targeted DNA and RNA sequencing. `r n_seq_dna_cells`/`r n_seq_cells` cells
additionally underwent whole genome DNA sequencing. `r n_pass_cells` cells 
passed QC.

# Celltype annotation

## VDJ + SHM + CSR

```{r get_celltypes}
cts <-
  ss_pass %>%
  # synthesise celltype annotations from VDJ + SHM + CSR
  mutate(
    celltype_VDJ_SHM_CSR = case_when(
      celltype_VDJ_recomb == "B cell" &
        (celltype_SHM == "mature B cell" |
         class_switch_recombination_CSR == TRUE) ~ "activated B",
      celltype_VDJ_recomb == "B cell" & celltype_SHM == "not mature B cell" ~ "naive B",
      celltype_VDJ_recomb == "alpha-beta T cell" ~ "T",
      celltype_VDJ_recomb == "not lymphocyte" ~ "other",
      TRUE ~ NA) %>%
      factor(levels = c("activated B", "naive B", "T", "other"))) %>%
  filter(!is.na(celltype_VDJ_SHM_CSR)) %>%
  distinct(cell_id, celltype_VDJ_SHM_CSR)

# subset samplesheet
ss_annot <-
  ss_pass %>%
  inner_join(cts)

# plot
cts %>%
  count(celltype_VDJ_SHM_CSR) %>%
  ggplot(aes(x = reorder(celltype_VDJ_SHM_CSR, -n), y = n, fill = celltype_VDJ_SHM_CSR)) +
  geom_col() +
  geom_text(aes(label = n), vjust = -0.5) +
  scale_fill_manual(values = pal) +
  theme_classic() +
  theme(legend.position = "none") +
  labs(x = "VDJ + SHM celltype")
```

## ImmuneLENS

```{r il_annot}
# immune lens annotations
immunelens <-
  "out/immunelens/scores.tsv" %>%
  read_tsv() %>%
  inner_join(ss_annot) %>%
  transmute(cell_id, name = paste0("cell_frac_", gene), cell_fraction,
            celltype_VDJ_SHM_CSR)

# plot
immunelens %>%
  filter(name %in% c("cell_frac_TCRA", "cell_frac_IGH")) %>%
  ggplot(aes(x = celltype_VDJ_SHM_CSR, y = cell_fraction, colour = celltype_VDJ_SHM_CSR)) +
  geom_boxplot() +
  geom_jitter(height = 0) +
  facet_grid(~ name) +
  scale_colour_manual(values = pal) +
  theme_bw() +
  theme(legend.position = "none", panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
```

## bj-expression

```{r bje_annot}
bje <-
  "out/BaseJumper/bj-expression/rna/PD63118_run/tertiary_analyses/classification_cell_typing/df_cell_typing_summary_singler_hpca_gtex_tcga.tsv" %>%
  read_tsv() %>%
  dplyr::rename(id = SampleId) %>%
  inner_join(ss_annot)

bje %>% count(Progenitor)

bje %>% filter(celltype_VDJ_SHM_CSR == "other") %>% count(Progenitor)

bje %>%
  mutate(celltype_bje = case_when(
    Progenitor %in% c("B_cell", "T_cells", "NK_cell", "Macrophage", "Monocyte") ~ Progenitor,
    TRUE ~ "other")) %>%
  count(celltype_VDJ_SHM_CSR, celltype_bje)
```

```{r}
ct_stats <-
  cts %>% count(celltype_VDJ_SHM_CSR) %>% {split(.$n, .$celltype_VDJ_SHM_CSR)}

il_stats <-
  immunelens %>%
  mutate(
    celltype = case_when(celltype_VDJ_SHM_CSR %in% c("activated B", "naive B") ~ "B",
                         TRUE ~ celltype_VDJ_SHM_CSR)) %>%
  group_by(celltype, name) %>%
  summarise(mean = mean(cell_fraction, na.rm = TRUE),
            max = max(cell_fraction, na.rm = TRUE),
            min = min(cell_fraction, na.rm = TRUE)) %>%
  mutate(stat = paste0(round(mean * 100), "% (", round(min * 100), "-",
                       round(max * 100), "%)")) %>%
  split(.$name) %>%
  purrr::map(~ split(.x$stat, .x$celltype))

bje_stats <-
  bje %>%
  left_join(cts) %>%
  transmute(cell_id, Progenitor,
            celltype_bje = case_when(Progenitor == "B_cell" ~ "B",
                                     Progenitor == "T_cells" ~ "T",
                                     TRUE ~ "other"),
            celltype = case_when(celltype_VDJ_SHM_CSR %in% c("activated B", "naive B") ~ "B",
                                 TRUE ~ celltype_VDJ_SHM_CSR),
            lineage = ifelse(celltype == "other", "other", "B/T")) %>%
  count(lineage, celltype, celltype_bje)
bje_stats %>% knitr::kable()

bje_non_BT <-
  bje %>%
  left_join(cts) %>%
  transmute(cell_id, Progenitor, celltype_VDJ_SHM_CSR) %>%
  filter(celltype_VDJ_SHM_CSR == "other") %>%
  group_by(Progenitor) %>%
  summarise(n = n(), cell_ids = paste(cell_id, collapse = ",")) %>%
  arrange(-n)
bje_non_BT %>% knitr::kable()

n_bt <- bje_stats %>% filter(lineage == "B/T") %>% pull(n) %>% sum()
n_bt_correct <- bje_stats %>% filter(lineage == "B/T" & celltype == celltype_bje) %>% pull(n) %>% sum()
n_other <- bje_stats %>% filter(lineage == "other") %>% pull(n) %>% sum()
```

Based on VDJ, SHM, and CSR annotations, 
`r ct_stats[["activated B"]] + ct_stats[["naive B"]]` cells were B cells 
(`r ct_stats[["activated B"]]` of which were activated), 
`r ct_stats[["T"]]` were T cells, and `r ct_stats$other` were other celltypes. 

`ImmuneLENS` scores for T cell fraction based on the TCRA locus strongly confirm 
the T cell annotations with a mean of `r il_stats$cell_frac_TCRA$T`, versus a
mean of `r il_stats$cell_frac_TCRA$B` for B cells.
Mean ImmuneLENS scores based on the IGH were `r il_stats$cell_frac_IGH$B` for B
cells and `r il_stats$cell_frac_IGH$T` for T cells. This correlated well with B
cell annotation, although did not differentiate B and T cells as effectively, 
with some overlap in ranges [see supplementary figure X]. 

`bj-expression` automated labelling of the RNA data was compared to the
DNA-based annotations and was found to perform quite sporadically. 
`r n_bt_correct`/`r n_bt` B and T lymphocytes were annotated correctly.
Among the `r n_other` cells that were not B or T cells according to the DNA
data, there were 2 platelets, 1 macrophage, 1 monocyte, 1 NK cell, and 1 
epithelial cell, which are plausible labels. However, two non-B/T cells were 
labelled as osteoblasts, which is an unrealistic label. Nonetheless, most of
these automated labels show consensus with the DNA-based annotations.

Final celltypes were assigned using the outcomes of the VDJ, SHM, and CSR
inspections, which were largely supported by the `ImmuneLENS` and
`bj-expression` results.

# Sequencing metrics

We load the DNA sequencing coverage.

```{r load_sequencing_metrics}
# get paths to mosdepth output
mosdepth <-
  ss_annot %>%
  transmute(
    seq_type, donor_id, id,
    out_dir = file.path("out/nf-resolveome", seq_type, donor_id, id),
    summary_txt = paste0(out_dir, "/mosdepth/", id, ".mosdepth.summary.txt"),
    dist = paste0(out_dir, "/mosdepth/", id, ".mosdepth.",
                  ifelse(seq_type == "dna", "global", "region"),
                  ".dist.txt")) %>%
  filter(file.exists(summary_txt), file.exists(dist))

# load mean coverage
cov <-
  xfun::cache_rds({
    cov <-
      split(mosdepth$summary_txt, mosdepth$id) %>%
      purrr::map(read_tsv) %>%
      bind_rows(.id = "id") %>%
      dplyr::rename(chr = chrom) %>%
      filter(!grepl("^GL", chr), !grepl("Un", chr), !grepl("random|HLA", chr),
            !grepl("alt$", chr), chr %in% c("total", "total_region")) %>%
      left_join(ss %>% dplyr::select(id, seq_type)) %>%
      filter(chr == "total" & seq_type == "dna" |
            chr == "total_region" & seq_type == "dnahyb") %>%
      transmute(id, name = "mean coverage", value = mean)
    cov
  }, file = "cov.rds", rerun = params$rerun)

# load coverage distribution
dist <-
  xfun::cache_rds({
    dist <-
      split(mosdepth$dist, mosdepth$id) %>%
      purrr::map(read_tsv, col_names = c("chr", "cov", "prop")) %>%
      bind_rows(.id = "id") %>%
      dplyr::filter(chr == "total") %>%
      inner_join(ss_annot)
    dist
  }, file = "dist.rds", rerun = params$rerun)

# get proportion of genome covered per id
perc_cov <-
  dist %>%
  filter(cov == 1) %>%
  transmute(id, name = "% genome covered", value = 100 * prop)
```

We load the RNA sequencing counts and features.

```{r read_and_gene_counts}
# dirs
bje_dir <- "out/BaseJumper/bj-expression/rna/PD63118_run/"

# load gene counts
gene_counts <-
  file.path(bje_dir, "secondary_analyses/quantification_salmon/df_gene_counts_salmon.tsv") %>%
  read_tsv() %>%
  mutate(id = gsub("salmon_outdir_", "", File)) %>%
  group_by(id) %>%
  summarise(value = n_distinct(gene_symbol_gene_id), name = "n genes")

# get read counts
read_counts <-
  file.path(bje_dir, "secondary_analyses/quantification_salmon/df_gene_counts_salmon.tsv") %>%
  read_tsv() %>%
  mutate(id = gsub("salmon_outdir_", "", File)) %>%
  group_by(id) %>%
  summarise(value = sum(countsFromAbundanceNo), name = "n counts")
```

We plot the coverage distribution.

```{r plot_coverage_dist}
dist %>%
  filter(prop >= 0.01) %>%
  ggplot(aes(x = cov, y = prop, colour = cell_id)) +
  geom_line() +
  theme_classic() +
  labs(x = "coverage", y = "proportion of genome") +
  facet_grid(~ seq_type, scales = "free_x") +
  theme(legend.position = "none")
```

We plot the coverage.

```{r plot_coverage, fig.height = 10, fig.width = 15}
p_dat <-
  bind_rows(read_counts, gene_counts, cov, perc_cov) %>%
  inner_join(ss_annot) %>%
  mutate(name = case_when(seq_type == "dnahyb" & name == "% genome covered" ~ "% panel covered",
                          TRUE ~ name)) %>%
  group_by(cell_id) %>%
  mutate(seq = paste(sort(unique(seq_type)), collapse = " + ")) %>%
  group_by(seq) %>%
  mutate(seq_n = paste0(seq, "\n(n = ", n_distinct(cell_id), ")"))

p1 <-
  p_dat %>%
  left_join(
    bind_rows(
      p_dat %>%
        filter(name == "mean coverage", seq == "dna + dnahyb + rna") %>%
        distinct(cell_id, cov = value),
      p_dat %>%
        filter(name == "mean coverage", seq == "dnahyb + rna") %>%
        distinct(cell_id, cov = value)
    )) %>%
  ggplot(aes(x = reorder(cell_id, -cov), y = value)) +
  geom_col(position = "dodge") +
  ggh4x::facet_nested(seq_type + name ~ seq_n, scales = "free",
                      space = "free_x", switch = "y") +
  guides(x = guide_axis(angle = -90)) +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        strip.placement = "outside",
        axis.title.y = element_blank(), axis.title.x = element_blank(),
        strip.background = element_rect(color = "white", fill = "#ededed"))

p2 <-
  p_dat %>%
  ggplot(aes(x = "all", y = value)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(height = 0, width = 0.2, alpha = 0.5, size = 0.5) +
  ggh4x::facet_nested(seq_type + name ~ ., scales = "free",
                      space = "free_x", switch = "y") +
  theme_minimal() +
  scale_y_continuous(position = "right", limits = c(0, NA)) +
  theme(strip.text = element_blank(),
        axis.text.x = element_blank(), axis.title.x = element_blank())

(p1 | p2) + plot_layout(widths = c(10, 1))
```

We plot the allelic balance of the coverage.

```{r heterozygosity}
# get genotyped snps
snps <-
  xfun::cache_rds({
    snps <-
      read_tsv("out/nf-resolveome/dna/PD63118/genotyping/snps/PD63118_genotyped_snps.tsv")
  }, file = "snps.rds", rerun = params$rerun)
snps_dnahyb <-
  read_tsv("out/nf-resolveome/dnahyb/PD63118/genotyping/snps/PD63118_genotyped_snps.tsv")

# calculate allelic statuses
allelic_statuses <-
  snps %>%
  mutate(allelic_status = case_when(
    ref_depth > 0 & mut_depth > 0 ~ "both",
    ref_depth > 0 & mut_depth == 0 ~ "one",
    ref_depth == 0 & mut_depth > 0 ~ "one",
    ref_depth == 0 & mut_depth == 0 ~ "neither")) %>%
  count(id, allelic_status) %>%
  group_by(id) %>%
  mutate(n_snps = sum(n), prop = n / n_snps)

# plot vaf dist per cell
snps_ls <- split(snps, snps$id)
purrr::map2(names(snps_ls), snps_ls, function(id_i, p_dat_i) {
  p_dat_i %>%
    filter(id == id_i) %>%
    mutate(mut = alt) %>%
    plot_vaf_dist(p_title = id_i)
})

# plot vaf dist overall
snps %>%
  mutate(mut = alt) %>%
  plot_vaf_dist()

# plot prop allelic dropout
allelic_statuses %>%
  left_join(allelic_statuses %>% filter(allelic_status == "both") %>% dplyr::select(id, arr = prop)) %>%
  mutate(prop_lab = paste0(round(arr * 100) , "%")) %>%
  ggplot(aes(x = reorder(id, -arr), y = prop, fill = allelic_status)) +
  geom_col(position = "stack") +
  geom_text(aes(y = 1, label = prop_lab), vjust = -1) +
  guides(x = guide_axis(angle = -90)) +
  scale_fill_brewer(palette = "Set2") +
  theme_classic()
```

```{r}
# summarise sequqncing stats
seq_stats <-
  p_dat %>%
  group_by(name, seq_type) %>%
  summarise(mean = mean(value), min = min(value), max = max(value)) %>%
  pivot_longer(cols = c(mean, min, max), names_to = "stat",
               values_to = "value") %>%
  split(.$seq_type) %>%
  purrr::map(~ split(.x, .x$name) %>% purrr::map(~ split(.x$value, .x$stat)))

# summarise allelic dropout stats
allelic_statuses_stats <-
  allelic_statuses %>%
  group_by(allelic_status) %>%
  summarise(min = min(prop), max = max(prop), mean = mean(prop))
```

Mean proportion coverage was
`r round(100 * seq_stats$dna[["prop of genome covered"]]$mean)`%
for DNA genome-wide, and
`r round(100 * seq_stats$dnahyb[["prop of genome covered"]]$mean)`%
for targeted DNA within the immune panel.
Average coverage was
`r round(seq_stats$dna[["mean coverage"]]$mean)`X (range
`r round(seq_stats$dna[["mean coverage"]]$min)`-`r round(seq_stats$dna[["mean coverage"]]$max)`X) 
for the DNA genome-wide, and
`r round(seq_stats$dnahyb[["mean coverage"]]$mean)`X (range
`r round(seq_stats$dnahyb[["mean coverage"]]$min)`-`r round(seq_stats$dnahyb[["mean coverage"]]$max)`X)
for the targeted DNA within the immune panel [see supplementary figure X].

In the RNA sequencing, the average number of unique genes counted per cell was
`r format(round(seq_stats$rna[["n genes"]]$mean), big.mark = ",", scientific = FALSE)` (range
`r format(round(seq_stats$rna[["n genes"]]$min), big.mark = ",", scientific = FALSE)` -
`r format(round(seq_stats$rna[["n genes"]]$max), big.mark = ",", scientific = FALSE)`)
and the average total count per cell was
`r format(round(seq_stats$rna[["n counts"]]$mean), big.mark = ",", scientific = FALSE)` (range
`r format(seq_stats$rna[["n counts"]]$min, big.mark = ",", scientific = FALSE)` -
`r format(seq_stats$rna[["n counts"]]$max, big.mark = ",", scientific = FALSE)`)
[see supplementary figure X].

# Copy number and LOH profiles

```{r cn_loh}
loh_counts <-
  ss_annot %>%
  distinct(cell_id, loh_1p) %>%
  count(loh_1p) %>%
  {split(.$n, .$loh_1p)}

loh_counts_ct_df <-
  ss_annot %>%
  distinct(cell_id, loh_1p, celltype_VDJ_SHM_CSR) %>%
  count(loh_1p, celltype_VDJ_SHM_CSR)
loh_counts_ct_df %>% knitr::kable()

loh_counts_ct <-
  loh_counts_ct_df %>%
  split(.$celltype_VDJ_SHM_CSR) %>%
  purrr::map(~ split(.x$n, .x$loh_1p))

n_act_b_loh <- loh_counts_ct[["activated B"]][["1"]]
n_act_b <- sum(unlist(loh_counts_ct[["activated B"]][c("1", "0")]))
perc_act_b_loh <- round(100 * n_act_b_loh / n_act_b)

dna_loh_counts <-
  ss_annot %>%
  filter(seq_type == "dna") %>%
  distinct(cell_id, loh_1p) %>%
  count(loh_1p) %>%
  {split(.$n, .$loh_1p)}
```

`r loh_counts[["1"]]` / `r loh_counts[["1"]] + loh_counts[["0"]]` cells had
evidence of 1p LOH. All cells with 1p LOH were activated B cells.
`r perc_act_b_loh`% (`r n_act_b_loh` / `r n_act_b`) of activated B cells had
1p LOH.

For cells with whole genome DNA sequencing, there is sufficient resolution in 
the BAF plots to manually place the breakpoints. Of the 
`r dna_loh_counts[["1"]] + dna_loh_counts[["0"]]`
cells with whole genome DNA sequencing,
`r dna_loh_counts[["1"]]` 
cells had evidence of 1p LOH. At least 8 distinct 1p
breakpoints were confirmed among these 
`r dna_loh_counts[["1"]]` 
cells, suggesting 8+ independent 1p copy number events in a population of just 
`r dna_loh_counts[["1"]] + dna_loh_counts[["0"]]`
cells [see figure X].

The Ginkgo copy number calls show no signal of 1p coverage 
loss across these cells [see supplementary figure X], suggesting that these are 
all copy-neutral LOH events. 

# Somatic mutation genotyping

```{r load_vars}
# load the genotyping and pile up reads across DNA and targeted DNA.
genos <-
  ss %>%
  # get genotyping for dna and dnahyb
  filter(seq_type %in% c("dna", "dnahyb")) %>%
  distinct(seq_type, donor_id) %>%
  mutate(genos = paste0("out/nf-resolveome/", seq_type, "/", donor_id,
                        "/genotyping/mutations/", donor_id,
                        "_annotated_mutations.tsv")) %>%
  purrr::pmap(function(seq_type, donor_id, genos) {
    read_tsv(genos) %>%
      mutate(donor_id = donor_id) %>%
      # convert id -> cell_id
      inner_join(ss %>% dplyr::select(id, cell_id)) %>%
      dplyr::select(-id)
  }) %>%
  # pile up
  bind_rows() %>%
  dplyr::select(-mut_vaf) %>%
  group_by(across(-matches("_depth$"))) %>%
  summarise(across(matches("_depth$"), \(x) sum(x, na.rm = TRUE))) %>%
  ungroup() %>%
  mutate(mut_vaf = mut_depth / total_depth) %>%
  # annotate mutations on 1p
  mutate(on_1p = ifelse(chr == "1" & pos < 123400000, TRUE, FALSE)) %>%
  # filter to only annotated, qc'ed cells
  inner_join(ss_annot %>% distinct(cell_id, celltype_VDJ_SHM_CSR, loh_1p))

# return
genos
```

We plot the distribution of genotyped mutations from NanoSeq across the genes.

```{r plot_genos, fig.height = 2, fig.width = 9}
load("../reference/dndscv/refcds_hg19.rda")

# plot CDS mutations in drivers
driver_genes %>%
  purrr::map(function(gene_i) {

    # get ccds
    g <- RefCDS[[which(purrr::map_lgl(RefCDS, ~ .x$gene_name == gene_i))]]
    ccds <-
      tibble::tibble(chr = g$chr,
                     start = g$intervals_cds[, 1],
                     end = g$intervals_cds[, 2]) %>%
      mutate(cds_interval = row_number()) %>%
      group_by(chr, start, end, cds_interval) %>%
      reframe(pos = start:end) %>%
      arrange(chr, pos) %>%
      mutate(aa = (row_number() - 1) %/% 3 + 1,
             cds_boundary = cds_interval != lag(cds_interval) | row_number() == 1,
             cds_end = row_number() == n(),
             aa_boundary = case_when(cds_boundary ~ aa - 0.5,
                                     cds_end ~ aa + 0.5,
                                     TRUE ~ NA))

    # plot
    p_muts <-
      genos %>%
      filter(gene == gene_i) %>%
      distinct(chr, pos, ref, alt, gene, strand, ref_cod, mut_cod, ref3_cod,
               mut3_cod, impact, ntchange, codonsub, pid, type) %>%
      mutate(impact = ifelse(impact == "no-SNV" & type %in% c("ins", "del"),
                             "Indels", impact))
    p_dat <-
      p_muts %>%
      right_join(ccds) %>%
      count(chr, pos, ref, alt, impact, aa, aa_boundary)

    # stats
    n_muts <- format(nrow(p_muts), big.mark = ",", scientific = FALSE)
    n_cds_muts <-
      p_dat %>%
      filter(!is.na(impact)) %>%
      nrow() %>%
      format(big.mark = ",", scientific = FALSE)

    # plot
    p_dat %>%
      ggplot(aes(x = aa, y = n, fill = impact)) +
      geom_vline(aes(xintercept = aa_boundary), colour = "grey") +
      geom_col(data = p_dat %>% filter(!is.na(impact)), width = 1,
               position = "stack") +
      scale_fill_manual(values = impact_colours) +
      theme_classic() +
      theme(panel.grid.major.x = element_blank(),
            panel.grid.minor.x = element_blank(),
            axis.line.y = element_blank()) +
      scale_y_continuous(expand = c(0, 0)) +
      scale_x_continuous(expand = c(0, 0)) +
      labs(title = paste0(gene_i, " CDS mutations (1 aa bins, n = ", n_muts,
                          ", n in CDS = ", n_cds_muts, ")"))

  })
```

We filter to `mut_vaf` > 0.25 and `mut_depth` > 1.

```{r genos_filter}
genos_filter <-
  genos %>%
  filter(mut_vaf > 0.2, mut_depth > 1)

# return
genos_filter
```

```{r}
# how many mutant sites across cells had reads?
genos %>%
  mutate(has_coverage = total_depth > 0) %>%
  group_by(cell_id) %>%
  summarise(prop_covered = sum(has_coverage) / n()) %>%
  ggplot(aes(x = reorder(cell_id, -prop_covered), y = prop_covered)) +
  geom_col()

# how many mutations were genotyped?
n_muts <- genos %>% distinct(chr, pos, ref, alt) %>% nrow()
n_muts_geno <- genos_filter %>% distinct(chr, pos, ref, alt) %>% nrow()

# which celltypes are mutated?
genos_filter %>% count(celltype_VDJ_SHM_CSR)

# what are the top most mutated genes?
top_mut_genes <-
  genos_filter %>% count(celltype_VDJ_SHM_CSR, gene) %>% arrange(-n)
top_mut_genes %>% knitr::kable()

# how many cells and what types of mutations do they have?
top_mut_genes_stats <-
  genos_filter %>%
  group_by(gene, impact) %>%
  mutate(n_mut_per_impact = n(),
         n_mut_per_impact_lab = paste(n(), impact)) %>%
  group_by(gene) %>%
  arrange(-n_mut_per_impact) %>%
  summarise(n_mut_cells = n_distinct(cell_id),
            n_mut = n(),
            impact = paste(unique(n_mut_per_impact_lab), collapse = ", ")) %>%
  arrange(-n_mut) %>%
  mutate(stat = paste0(gene, " (n = ", n_mut,
                       ", n mutant cells = ", n_mut_cells, "; ",
                       impact, ")"))
```

DNA and targeted DNA genotyping counts were piled up per cell.
`r format(n_muts_geno, big.mark = ",", scientific = FALSE)` /
`r format(n_muts, big.mark = ",", scientific = FALSE)`
NanoSeq mutations were successfully genotyped in this population of cells.
All `r format(n_muts_geno, big.mark = ",", scientific = FALSE)` mutations were
found exclusively in activated B cells [see figure X]. 

The top mutated genes were 
`r top_mut_genes_stats[1, ]$stat`,
`r top_mut_genes_stats[2, ]$stat`, and
`r top_mut_genes_stats[3, ]$stat`.


```{r plot_vaf_dist_hyb, fig.width = 8, fig.height = 10}
# % of B cells with a nonsynonymous mutation
n_mat_b_cells <-
  man_insp %>%
  filter(celltype_SHM == "mature B cell") %>%
  nrow()
p_dat <-
  genos_filter %>%
  filter(impact != "Synonymous") %>%
  group_by(gene) %>%
  summarise(n_cells = n_distinct(cell_id)) %>%
  mutate(prop_cells = n_cells / n_mat_b_cells)
p2 <-
  p_dat %>%
  ggplot(aes(x = reorder(gene, -prop_cells), y = prop_cells)) +
  geom_col(fill = "#d6630d") +
  theme_classic() +
  labs(x = "gene", y = "% of mature B cells with a driver mutation") +
  scale_y_continuous(expand = c(0, 0)) +
  guides(x = guide_axis(angle = -45))

# mutations per gene
p1 <-
  genos_filter %>%
  left_join(man_insp) %>%
  add_count(gene, name = "total") %>%
  count(gene, impact, total, celltype_SHM) %>%
  mutate(impact = ifelse(impact == "no-SNV", "Synonymous", impact) %>% factor(levels = rev(names(impact_colours)))) %>%
  left_join(p_dat %>% distinct(gene, prop_cells)) %>%
  ggplot(aes(x = reorder(gene, -prop_cells), y = n, fill = impact)) +
  geom_col() +
  scale_fill_manual(values = impact_colours) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(axis.text.x = element_blank(), axis.title.x = element_blank(),
        axis.ticks.x = element_blank()) +
  labs(y = "n mutations")

# plot
p1 / p2
```

We plot the impact of the mutations genotyped.

```{r plot_impact}
genos_filter %>%
  distinct(chr, pos, ref, alt, impact, gene) %>%
  add_count(gene) %>%
  ggplot(aes(x = reorder(gene, -n), fill = impact)) +
  geom_bar() +
  geom_text(aes(label = n, y = n), vjust = -0.5) +
  scale_fill_manual(values = impact_colours) +
  guides(x = guide_axis(angle = -90)) +
  theme_classic() +
  labs(x = "", y = "n mutations")
```

We generate a heatmap of all mutations.

```{r plot_heatmap, fig.width = 20, fig.height = 20}
plot_vaf_heatmap(genos, p_title = "all mutations", show_rownames = FALSE,
                 annotations = c("celltype_VDJ_SHM_CSR", "loh_1p"))
```

```{r plot_heatmap_filtered, fig.width = 20, fig.height = 20}
plot_vaf_heatmap(genos_filter, p_title = "filtered mutations",
                 show_rownames = FALSE,
                 annotations = c("celltype_VDJ_SHM_CSR", "loh_1p"))
```

```{r plot_heatmap_filtered_shared, fig.width = 20, fig.height = 20}
p <-
  genos_filter %>%
  group_by(chr, pos, ref, alt) %>%
  filter(n() > 1) %>%
  plot_vaf_heatmap(p_title = "filtered shared mutations",
                   annotations = c("celltype_VDJ_SHM_CSR", "loh_1p"))
print(p)
```

```{r plot_heatmap_filtered_nonsynonymous, fig.width = 20, fig.height = 20}
p <-
  genos_filter %>%
  filter(impact != "Synonymous") %>%
  plot_vaf_heatmap("filtered non-synonymous mutations",
                   annotations = c("celltype_VDJ_SHM_CSR", "loh_1p"))
print(p)
```

```{r plot_heatmap_filtered_TNFRSF14, fig.width = 20, fig.height = 10}
p <-
  genos_filter %>%
  filter(gene == "TNFRSF14") %>%
  plot_vaf_heatmap("non-synonymous TNFRSF14 mutations",
                   annotations = c("celltype_VDJ_SHM_CSR", "loh_1p"))
print(p)
```

```{r plot_heatmap_filtered_TNFRSF14_nonsynonymous, fig.width = 15, fig.height = 10}
p <-
  genos_filter %>%
  filter(gene == "TNFRSF14", impact != "Synonymous") %>%
  plot_vaf_heatmap("TNFRSF14 mutations",
                   annotations = c("celltype_VDJ_SHM_CSR", "loh_1p"))
print(p)
```

We plot TNFRSF14 mutant calls in the 1p LOH and non-1p LOH cells.

```{r}
p <-
  genos_filter %>%
  filter(gene == "TNFRSF14") %>%
  ggplot(aes(x = loh_1p, y = mut_vaf)) +
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(height = 0, width = 0.1) +
  theme_classic()
print(p)
```

We plot the VAF distribution of the mutations.

```{r}
genos %>%
  left_join(ss) %>%
  filter(mut_vaf > 0) %>%
  ggplot(aes(x = mut_vaf, fill = on_1p & loh_1p == "1")) +
  geom_histogram() +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_brewer(palette = "Set1")
genos_filter %>%
  left_join(ss) %>%
  ggplot(aes(x = mut_vaf, fill = on_1p & loh_1p == "1")) +
  geom_histogram() +
  lims(x = c(0, NA)) +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_brewer(palette = "Set1")
```

```{r plot_drivers_per_cell}
p_dat <-
  genos_filter %>%
  filter(impact != "Synonymous") %>%
  arrange(loh_1p) %>%
  mutate(cell_id = forcats::fct_inorder(cell_id)) %>%
  add_count(gene) %>%
  add_count(gene, cell_id, name = "n per cell") %>%
  mutate(gene = paste0(gene, " (", n, ")")) %>%
  arrange(n) %>%
  mutate(gene = forcats::fct_inorder(gene)) %>%
  distinct(cell_id, celltype_VDJ_SHM_CSR, gene, loh_1p, `n per cell`)

p1 <-
  p_dat %>%
  ggplot(aes(x = cell_id, y = 1, fill = loh_1p)) +
  geom_tile() +
  scale_fill_brewer(palette = "Set1") +
  theme_void()

p2 <-
  p_dat %>%
  ggplot(aes(x = cell_id, y = gene, fill = `n per cell`)) +
  geom_tile() +
  theme_classic() +
  guides(x = guide_axis(angle = -90)) +
  viridis::scale_fill_viridis() +
  coord_equal()

p1 / p2 + plot_layout(heights = c(1, 10), guides = "collect")
```

# Somatic mutation calling

We load mutations generated by previous reports and we combine the calls.

```{r load_vafs}
# get nr and nv
bj_muts_38 <-
  c("dna", "dnahyb") %>%
  purrr::set_names() %>%
  purrr::map(function(seq_type) {
    c("mut_depth" = "NV", "total_depth" = "NR") %>%
      purrr::map(function(i) {
        paste0("out/BaseJumper/bj-somatic-variantcalling/", seq_type,
               "/PD63118_run/SOMATIC_VARIANT_WORKFLOW_Heuristic_Filter_SEQUOIA", 
               "/Sequoia_group_PD63118_bino-10_rhosnp0.4_rhoindel0.4_mincov10_maxcov500_both_",
               i, "_filtered_all.txt") %>%
          read.table() %>%
          tibble::rownames_to_column(var = "mut_id")
      }) %>%
      bind_rows(.id = "name") %>%
      pivot_longer(cols = -c("name", "mut_id"), names_to = "id") %>%
      pivot_wider() %>%
      separate_wider_delim(cols = "mut_id", delim = "_", cols_remove = FALSE,
                           names = c("chr", "pos", "ref", "mut")) %>%
      mutate(pos = as.numeric(pos)) %>%
      filter(mut_depth > 0)
  }) %>%
  bind_rows(.id = "seq_type") %>%
  left_join(ss %>% dplyr::select(id, cell_id)) %>%
  group_by(cell_id) %>%
  mutate(seq_type = paste(unique(seq_type), collapse = "+")) %>%
  # pileup across dna and dnahyb
  group_by(chr, pos, ref, mut, mut_id, cell_id, seq_type) %>%
  summarise(mut_depth = sum(mut_depth), total_depth = sum(total_depth)) %>%
  ungroup() %>%
  mutate(mut_vaf = mut_depth / total_depth)

# annotate bj_muts with dndscv
refcds <- "../reference/dndscv/RefCDS_human_GRCh38_GencodeV18_recommended.rda"
dndscv_in <-
  bj_muts_38 %>%
  transmute(sampleID = "", chr = gsub("chr", "", chr), pos, ref, mut) %>%
  distinct()
dndscv_out <-
  dndscv::dndscv(dndscv_in, max_muts_per_gene_per_sample = Inf,
                 max_coding_muts_per_sample = Inf, outp = 1, refdb = refcds)

# add mutation annotations
bj_muts_38 <-
  bj_muts_38 %>%
  left_join(
    dndscv_out$annotmuts %>%
      mutate(chr = paste0("chr", chr)) %>%
      dplyr::select(-sampleID)) %>%
  left_join(man_insp)

# lift over to grch37
bj_muts <-
  bj_muts_38 %>%
  {GRanges(seqnames = .$chr,
           ranges = IRanges(start = .$pos, end = .$pos),
           pos = .$pos)} %>%
  liftOver(import.chain("../reference/liftOver/hg38ToHg19.over.chain")) %>%
  unlist() %>%
  tibble::as_tibble() %>%
  distinct() %>%
  dplyr::transmute(chr = seqnames, pos_37 = start, pos) %>%
  inner_join(bj_muts_38) %>%
  mutate(pos = pos_37,
         mut_id = paste(chr, pos, ref, mut, sep = "_"))

# return
bj_muts
```

Plot the distribution of mutation types per cell.

```{r plot_mut_types_all, fig.width = 14}
# all muts
bj_muts %>%
  filter(!is.na(impact)) %>%
  mutate(group = "all") %>%
  bind_rows(bj_muts %>% filter(impact != "Non-coding") %>% mutate(group = "coding")) %>%
  add_count(group, cell_id) %>%
  ggplot(aes(x = reorder(cell_id, -n), fill = impact)) +
  geom_bar() +
  scale_fill_manual(values = impact_colours) +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0)) +
  guides(x = guide_axis(angle = -90)) +
  labs(x = "") +
  facet_grid(group ~ ., scales = "free_y")
```

Plot the VAF heatmap.

```{r plot_heatmap_vaf, fig.width = 20, fig.height = 20, eval = F}
bj_muts %>%
  plot_vaf_heatmap(p_title = "all mutations", show_rownames = FALSE,
                   annotations = c("loh_1p"))
```

# VAF distribution

Plot the VAF distribution.

```{r plot_vaf_dist, fig.height = 4, fig.width = 5, eval = F}

```

# Phylogeny

```{r phylo}
tree <-
  file.path(bj_run_dir, "/SOMATIC_VARIANT_WORKFLOW_Heuristic_Filter_SEQUOIA/") %>%
  list.files(pattern = "_both_tree_with_branch_length.tree", full.names = TRUE) %>%
  ape::read.tree()
```