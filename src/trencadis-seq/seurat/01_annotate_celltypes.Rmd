---
title: "Celltype annotation"
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
params:
  out_dir: NULL
  rerun: false
  min_n_cells: 3
  min_nfeature_rna: 500
  max_nfeature_rna: 2000
  min_ncount_rna: 1000
  max_ncount_rna: 15000
  max_percent_mt: 5
  celltypes: NULL
output:
  html_document:
    keep_md: true
    code_folding: show
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    number_sections: true
    theme: lumen
---

```{r initialise, include = F}
# params_i <- list(min_n_cells = 3, min_nfeature_rna = 500, max_nfeature_rna = 2000, min_ncount_rna = 1000, max_ncount_rna = 15000, max_percent_mt = 5, rerun = FALSE); params_i$out_dir <- paste0("out/trencadis-seq/seurat/ncells_", params_i$min_n_cells, "_nfeature_", params_i$min_nfeature_rna, "-", params_i$max_nfeature_rna, "_ncount_", params_i$min_ncount_rna, "-", params_i$max_ncount_rna, "_percent_mt_", params_i$max_percent_mt, "/"); params_i$celltypes <- paste0(params_i$out_dir, "cluster_summary_annotated.tsv")
# rmarkdown::render("src/trencadis-seq/seurat/01_annotate_celltypes.Rmd", params = params_i, output_file = "nf-trencadis-seq_thyroid_annotate_celltypes.html", output_dir = params_i$out_dir)

# libraries
library(magrittr)
library(Seurat)
library(SingleR)
library(ggalluvial)
library(ggplot2)
library(Matrix)
library(DoubletFinder)

# set seed for reproducibility
set.seed(42)
random_seed <- 42

# set ggplot presets
ggplot2::theme_set(ggplot2::theme_bw())
ggplot2::theme_update(legend.text = ggplot2::element_text(size = 7))

# knitr options
knitr::opts_knit$set(root.dir = "../../..")
knitr::opts_chunk$set(
  warning = FALSE, dpi = 300, message = FALSE,
  fig.align = "center",
  cache.path = file.path(
    params$out_dir,
    "/nf-trencadis-seq_thyroid_annotate_celltypes_cache/html/"))
```

# Parameters

```{r params, echo = FALSE}
params %>%
  tibble::enframe() %>%
  knitr::kable()
```

# Data

First, we must move the cellranger h5 objects from IRODS to `nfs`.

```{bash iget_h5, eval = F}
# load irods
module load IRODS/1.0
iinit

# dirs and samples
cellranger_dir=/seq/illumina/runs/49/49200/cellranger/
samples=(PD63118b_st0001 PD63118b_st0002)
sample_subdirs=(cellranger720_count_49200_7613STDY14897605_GRCh38-3_0_0 cellranger720_count_49200_7613STDY14897606_GRCh38-3_0_0)

for i in ${!samples[@]} ; do

  # sample
  sample=${samples[$i]}
  sample_dir=$cellranger_dir/${sample_subdirs[$i]}
  echo $sample 
  echo $sample_dir

  # dir
  data_dir=data/trencadis-seq/cellranger/$sample/
  mkdir -p $data_dir

  # iget
  iget -k $sample_dir/filtered_feature_bc_matrix.h5 $data_dir
  echo $sample_dir/filtered_feature_bc_matrix.h5 > $data_dir/README.txt

done
```

We load the `h5` objects, combine them and convert to a `Seurat` object.

```{r load_seu}
seu <-
  xfun::cache_rds({
    
    # list of h5s
    h5 <-
      "ls data/trencadis-seq/cellranger/*/filtered_feature_bc_matrix.h5" %>%
      system(intern = TRUE) %>%
      purrr::map(Read10X_h5)

    # get all barcodes
    unique_barcodes <- lapply(h5, colnames) %>% unlist() %>% unique()

    # align and sum matrices
    h5 <-
      purrr::map(h5, function(m) {
        # reorder and fill in missing barcodes
        missing <- setdiff(unique_barcodes, colnames(m))
        if (length(missing) > 0) {
          zero_mat <- Matrix(0, nrow = nrow(m), ncol = length(missing), sparse = TRUE)
          colnames(zero_mat) <- missing
          rownames(zero_mat) <- rownames(m)
          m <- cbind(m, zero_mat)
        }
        # reorder to consistent barcode order
        m[, unique_barcodes]
      }) %>%
      # sum matrices
      {Reduce(`+`, .)}

    # save combined matrix for celltypist
    write.csv(as.matrix(h5), file = "out/trencadis-seq/celltypist/matrix.csv",
              quote = FALSE)

    # create seurat object
    seu <- CreateSeuratObject(counts = h5, min.cells = params$min_n_cells)

    # return
    seu

  }, file = "seu.rds", rerun = params$rerun)
```

# Pre-processing

The steps below encompass the standard pre-processing workflow for scRNA-seq data in Seurat. These represent the selection and filtration of cells based on QC metrics, data normalization and scaling, and the detection of highly variable features.

## QC and selecting cells for further analysis

Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. A few QC metrics commonly used by the community include

- The number of unique genes detected in each cell.
  - Low-quality cells or empty droplets will often have very few genes
  - Cell doublets or multiplets may exhibit an aberrantly high gene count
- Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)
- The percentage of reads that map to the mitochondrial genome
  - Low-quality / dying cells often exhibit extensive mitochondrial contamination
  - We calculate mitochondrial QC metrics with the `PercentageFeatureSet()` function, which calculates the percentage of counts originating from a set of features
  - We use the set of all genes starting with MT- as a set of mitochondrial genes

```{r feature_plots}
seu[["percent.mt"]] <- PercentageFeatureSet(seu, pattern = "^MT-")

# violin of qc metrics
VlnPlot(seu, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# ncount vs mt and nfeature
FeatureScatter(seu, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(seu, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
```

We apply filters.

```{r filter}
seu_n_prefilter <- ncol(seu)
seu <-
  xfun::cache_rds({
    seu %>%
      subset(subset = nFeature_RNA > params$min_nfeature_rna &
                      nFeature_RNA < params$max_nfeature_rna &
                      nCount_RNA > params$min_ncount_rna &
                      nCount_RNA < params$max_ncount_rna &
                      percent.mt < params$max_percent_mt)
  }, file = "seu_filtered.rds", rerun = params$rerun)
seu_n_postfilter <- ncol(seu)

cat("Number of cells pre-filtering:", seu_n_prefilter, "\n")
cat("Number of cells post-filtering:", seu_n_postfilter, "\n")
```

## Normalisation and scaling

```{r norm}
seu <-
  xfun::cache_rds({
    seu <- NormalizeData(seu)
    seu <- FindVariableFeatures(seu)
    seu <- ScaleData(seu, features = rownames(seu))
  }, file = "seu_normalized.rds", rerun = params$rerun)
```

# Dimensionality reduction

## Linear dimensionality reduction

Next we perform PCA on the scaled data. By default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to choose a different subset (if you do want to use a custom subset of features, make sure you pass these to ScaleData first).

For the first principal components, Seurat outputs a list of genes with the most positive and negative loadings, representing modules of genes that exhibit either correlation (or anti-correlation) across single-cells in the dataset.

```{r pca}
seu <-
  xfun::cache_rds({
    RunPCA(seu, features = VariableFeatures(seu))
  }, file = "seu_pca.rds", rerun = params$rerun)

# dim loadings
VizDimLoadings(seu, dims = 1:2, reduction = "pca")

# pca
DimPlot(seu, reduction = "pca") + NoLegend()

# heatmap
DimHeatmap(seu, dims = 1, cells = 500, balanced = TRUE)
```

## Determine the dimensionality of the data

To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metafeature’ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many components should we choose to include? 10? 20? 100?

In Macosko et al, we implemented a resampling test inspired by the JackStraw procedure. While still available in Seurat (see previous vignette), this is a slow and computationally expensive procedure, and we is no longer routinely used in single cell analysis.

An alternative heuristic method generates an ‘Elbow plot’: a ranking of principle components based on the percentage of variance explained by each one (`ElbowPlot()` function). 

```{r elbow}
ElbowPlot(seu)
n_dims <- 8
```

## Non-linear dimensionality reduction (UMAP)

Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. The goal of these algorithms is to learn underlying structure in the dataset, in order to place similar cells together in low-dimensional space. Therefore, cells that are grouped together within graph-based clusters determined above should co-localize on these dimension reduction plots.

While we and others have routinely found 2D visualization techniques like tSNE and UMAP to be valuable tools for exploring datasets, all visualization techniques have limitations, and cannot fully represent the complexity of the underlying data. In particular, these methods aim to preserve local distances in the dataset (i.e. ensuring that cells with very similar gene expression profiles co-localize), but often do not preserve more global relationships. We encourage users to leverage techniques like UMAP for visualization, but to avoid drawing biological conclusions solely on the basis of visualization techniques.

```{r umap, fig.width = 10}
seu <-
  xfun::cache_rds({
    RunUMAP(seu, dims = 1:n_dims)
  }, file = "seu_umap.rds", rerun = params$rerun)

# dimplot
DimPlot(seu, reduction = "umap") & coord_equal()

# violin plots of features per cluster
VlnPlot(seu, features = c("nCount_RNA", "nFeature_RNA", "percent.mt"))
```

## Clustering

```{r clust}
# find neighbours
seu <- FindNeighbors(seu, dims = 1:n_dims)

# try many resolutions
resolutions <- seq(0.2, 1.2, 0.1)
purrr::walk(resolutions, function(res) {
  p <-
    FindClusters(seu, resolution = res, dims = 1:n_dims) %>%
    DimPlot() +
    ggtitle(paste("resolution =", res)) +
    coord_equal()
  print(p)
})

# set a resolution
resolution <- 1
seu <-
  xfun::cache_rds({
    FindClusters(seu, resolution = resolution, dims = 1:n_dims)
  }, file = "seu_clustered.rds", rerun = params$rerun)

# final resolution
DimPlot(seu) + ggtitle(paste("final resolution =", resolution))
```

## Remove doublets

```{r doublets}
# pK identification (no ground-truth)
sweep_list <- paramSweep(seu, PCs = 1:n_dims)
sweep_stats <- summarizeSweep(sweep_list, GT = FALSE)
bcmvn <- find.pK(sweep_stats)
optimal_pk <-
  bcmvn %>%
  dplyr::filter(BCmetric == max(BCmetric)) %>%
  dplyr::pull(pK) %>%
  as.numeric()

# homotypic doublet proportion estimate (assuming 7.5% doublet formation rate)
annotations <- seu$seurat_clusters
homotypic_prop <- modelHomotypic(annotations)

# multiply by number of cells to get the number of expected multiplets
multiplet_rate <- 0.075
n_exp_poi <- round(multiplet_rate * ncol(seu))
n_exp_poi_adj <- round(n_exp_poi * (1 - homotypic_prop))

# run DoubletFinder with varying classification stringencies
seu <-
  xfun::cache_rds({
    seu <-
      doubletFinder(seu, PCs = 1:n_dims, pK = optimal_pk, nExp = n_exp_poi_adj)
    seu
  }, file = "seu_doublets.rds", rerun = params$rerun)
df_col <-
  colnames(seu@meta.data)[grepl("DF.classifications", colnames(seu@meta.data))]

# plot doublets
DimPlot(seu, group.by = df_col) + coord_equal()

# count doublets
table(seu@meta.data[, df_col])

# remove doublets
seu <-
  xfun::cache_rds({
    seu <- seu[, seu@meta.data[, df_col] == "Singlet"]
    seu
  }, file = "seu_singlets.rds", rerun = params$rerun)
```

# Celltype annotation

## Differentially expressed features

Seurat can help you find markers that define clusters via differential expression (DE). By default, it identifies positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. FindAllMarkers() automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

In Seurat v5, we use the presto package (as described here and available for installation here), to dramatically improve the speed of DE analysis, particularly for large datasets. For users who are not using presto, you can examine the documentation for this function (?FindMarkers) to explore the min.pct and logfc.threshold parameters, which can be increased in order to increase the speed of DE testing.

```{r markers}
markers <-
  xfun::cache_rds({
    markers <- FindAllMarkers(seu, only.pos = TRUE)
    markers
  }, file = "markers.rds", rerun = params$rerun)
```

Let's look at the top 10 markers for each cluster.

```{r markers_heatmap, fig.height = 10, fig.width = 10}
top_10_markers <-
  markers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1) %>%
  dplyr::slice_head(n = 10) %>%
  dplyr::ungroup()

# plot heatmap
DoHeatmap(seu, features = top_10_markers$gene) + NoLegend()
```

## Thyroid-specific celltype markers from Massalha et al., 2024

In the 2024 paper *A developmental cell atlas of the human thyroid gland*,
they undertook "manual assessment of well-established cell-type specific marker
genes in high-resolution clusters." Here, we plot the expression of these 
markers across the clusters.

```{r thyroid_markers, fig.height = 10}
thy_markers <-
  "data/trencadis-seq/celltype_annotations/massalha2024_thyroid_celltype_markers.tsv" %>%
  readr::read_tsv()

# add a module score for each of the marker sets
seu <-
  xfun::cache_rds({
    seu <-
      seu %>%
      AddModuleScore(features = split(thy_markers$gene, thy_markers$celltype),
                     name = paste0("module_", unique(thy_markers$celltype)))
    seu
  }, file = "seu_module_scores.rds", rerun = params$rerun)

# prep dotplot of expression
p_dat <-
  seu@assays$RNA$count %>%
  tibble::as_tibble(rownames = "gene") %>%
  tidyr::pivot_longer(cols = -gene,
                      names_to = "barcode", values_to = "count") %>%
  # subset to marker genes
  dplyr::inner_join(thy_markers) %>%
  # add cluster labels
  dplyr::left_join(tibble::tibble(barcode = colnames(seu),
                                  cluster = Idents(seu))) %>%
  # calculate expression stats
  dplyr::group_by(gene, celltype, cluster) %>%
  dplyr::summarise(`% cells expressing` = 100 * sum(count > 0) / dplyr::n(),
                   `avg count` = mean(count)) %>%
  dplyr::mutate(gene_mean_pct = mean(`% cells expressing`)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(gene = forcats::fct_reorder(gene, gene_mean_pct))

# plot expression dotplot
p_dat %>%
  ggplot(aes(x = cluster, y = gene, size = `% cells expressing`,
             colour = `avg count`)) +
  geom_point() +
  ggh4x::facet_grid2(celltype ~ ., scales = "free_y", space = "free_y") +
  theme_classic() +
  viridis::scale_colour_viridis() +
  scale_x_discrete(position = "top") +
  # no dot if expression = 0
  scale_size_continuous(range = c(-1, 8))

# plot module scores
seu@meta.data %>%
  dplyr::select(dplyr::starts_with("module_")) %>%
  dplyr::mutate(cluster = Idents(seu)) %>%
  tibble::rownames_to_column("barcode") %>%
  tidyr::pivot_longer(cols = -c(barcode, cluster),
                      names_to = "celltype", values_to = "score") %>%
  ggplot(aes(x = cluster, y = score)) +
  geom_violin() +
  geom_jitter(height = 0, size = 0.1, alpha = 0.5) +
  facet_grid(celltype ~ .) +
  theme_bw()
```

## CellTypist

`CellTypist` was run on the dataset using the `Immune_All_Low.pkl` model.

```{bash run_celltypist, eval = F}
module load python-3.12.0/perl-5.38.0
celltypist \
  --indata out/trencadis-seq/celltypist/matrix.csv \
  --model Immune_All_Low.pkl \
  --outdir out/trencadis-seq/celltypist/
```

We apply the annotations here.

```{r celltypist, fig.height = 12, fig.width = 12}
seu <-
  xfun::cache_rds({
    # get high level labels from the encyclopedia
    ct_labels <-
      "../../reference/celltypist/Basic_celltype_information.tsv" %>%
      readr::read_tsv() %>%
      janitor::clean_names() %>%
      dplyr::mutate(predicted_labels = low_hierarchy_cell_types)

    # get annots
    ct_annots <-
      "out/trencadis-seq/celltypist/20250801/predicted_labels.csv" %>%
      readr::read_csv() %>%
      dplyr::rename(barcode = `...1`) %>%
      dplyr::left_join(ct_labels)

    # add fine label
    seu$celltypist_annot_fine <-
      seu@meta.data %>%
      tibble::as_tibble() %>%
      dplyr::mutate(barcode = colnames(seu)) %>%
      dplyr::left_join(ct_annots) %>%
      dplyr::pull(predicted_labels)

    # add main label
    seu$celltypist_annot_main <-
      seu@meta.data %>%
      tibble::as_tibble() %>%
      dplyr::mutate(barcode = colnames(seu)) %>%
      dplyr::left_join(ct_annots) %>%
      dplyr::pull(high_hierarchy_cell_types)

    # return
    seu
  }, file = "seu_celltypist.rds", rerun = params$rerun)

# dimplots
DimPlot(seu, group.by = "celltypist_annot_main", label = TRUE) +
  NoLegend()
DimPlot(seu, group.by = "celltypist_annot_fine", label = TRUE) +
  NoLegend()
```

## SingleR

```{r singler, fig.width = 12, fig.height = 12}
# predict celltypes using HPCA
singler_hpca_annots <-
  xfun::cache_rds({
    # load HPCA
    singler_refs <- celldex::HumanPrimaryCellAtlasData()

    # predict celltypes using HPCA
    singler_hpca_annots <-
      SingleR::SingleR(
        test = SeuratWrappers::as.cell_data_set(seu, assay = "RNA")@assays@data$counts,
        ref = singler_refs,
        labels = singler_refs@colData$label.fine
      )

    # return
    singler_hpca_annots
  }, file = "singler_hpca_annots.rds", rerun = params$rerun)

# predict celltypes using BPE
singler_bpe_annots <-
  xfun::cache_rds({
    # load BluePrint ENCODE
    singler_refs <- celldex::BlueprintEncodeData()

    # predict celltypes using Blueprint ENCODE
    singler_bpe_annots <-
      SingleR::SingleR(
        test = SeuratWrappers::as.cell_data_set(seu, assay = "RNA")@assays@data$counts,
        ref = singler_refs,
        labels = singler_refs@colData$label.fine
      )

    # return
    singler_bpe_annots
  }, file = "singler_bpe_annots.rds", rerun = params$rerun)

# label seu
seu <-
  xfun::cache_rds({

    # add HPCA fine and main labels
    seu$singler_hpca_annot_fine <- singler_hpca_annots$labels
    seu$singler_hpca_annot_main <- gsub(":.*", "", seu$singler_hpca_annot_fine)

    # add BPE labels
    seu$singler_bpe_annot <- singler_bpe_annots$labels

    # return
    seu

  }, file = "seu_singler.rds", rerun = params$rerun)
```

### Human Primary Cell Atlas 

```{r singler_hpca, fig.width = 12, fig.height = 12}
# plot heatmap
SingleR::plotScoreHeatmap(
  singler_hpca_annots,
  show.labels = TRUE,
  annotation_col = data.frame(
    cluster = Idents(seu),
    row.names = rownames(singler_hpca_annots)
  ))

# plot fine and main labels
DimPlot(seu, group.by = "singler_hpca_annot_fine", label = TRUE) +
  NoLegend()
DimPlot(seu, group.by = "singler_hpca_annot_main", label = TRUE) +
  NoLegend()
```

### BluePrint ENCODE

```{r singler_bpe, fig.width = 12, fig.height = 12}
# plot heatmap
SingleR::plotScoreHeatmap(
  singler_bpe_annots,
  show.labels = TRUE,
  annotation_col = data.frame(
    cluster = Idents(seu),
    row.names = rownames(singler_bpe_annots)
  ))

# plot labels
DimPlot(seu, group.by = "singler_bpe_annot", label = TRUE) +
  NoLegend()
```

## Alluvial plot of all annotations

We can visualise how cells are annotated across all methods using an alluvial
plot.

```{r alluvial_plot_of_annots, fig.height = 12, fig.width = 20}
dplyr::as_tibble(seu@meta.data) %>%
  dplyr::count(seurat_clusters, singler_bpe_annot, singler_hpca_annot_main,
               celltypist_annot_main) %>%
  ggplot(aes(y = n, axis1 = seurat_clusters, axis2 = singler_bpe_annot,
             axis3 = singler_hpca_annot_main, axis4 = celltypist_annot_main)) +
  ggalluvial::geom_alluvium(aes(fill = seurat_clusters)) +
  ggalluvial::geom_stratum(alpha = 0.25) +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("seurat_clusters", "singler_bpe_annot",
                              "singler_hpca_annot_main",
                              "celltypist_annot_main")) +
  theme(legend.position = "none")
```

## Summarise annotations per cluster

Now, we can summarise all of this information per cluster to arrive at 
consensus celltype annotations. We will consider the top 5 markers, the top 
CellTypist predictions, and the top SingleR predictions from each atlas.

```{r summ}
ct_annot_summ <-
  xfun::cache_rds({
    seu@meta.data %>%
      dplyr::as_tibble() %>%
      dplyr::group_by(seurat_clusters) %>%
      tidyr::pivot_longer(
        cols = c(celltypist_annot_main, celltypist_annot_fine,
                 singler_hpca_annot_main, singler_hpca_annot_fine,
                 singler_bpe_annot)) %>%
      dplyr::add_count(seurat_clusters, name, name = "n_cells") %>%
      dplyr::count(seurat_clusters, name, n_cells, value) %>%
      dplyr::group_by(seurat_clusters, name) %>%
      dplyr::mutate(prop = n / n_cells,
                    prop_rank = rank(-prop, ties.method = "first"),
                    value = paste0(value, " (", 100 * round(prop, 3), "%)")) %>%
      dplyr::group_by(seurat_clusters, n_cells, name) %>%
      dplyr::arrange(prop_rank) %>%
      dplyr::summarise(value = paste(value, collapse = ", ")) %>%
      dplyr::ungroup() %>%
      tidyr::pivot_wider() %>%
      dplyr::mutate(prop_cells = n_cells / sum(n_cells)) %>%
      # add top 5 markers per cluster
      dplyr::left_join(
        top_10_markers %>%
          dplyr::rename(seurat_clusters = cluster) %>%
          dplyr::group_by(seurat_clusters) %>%
          dplyr::slice_max(p_val_adj, n = 5) %>%
          dplyr::summarise(top_5_markers = paste(gene, collapse = ", "))
      ) %>%
      # add median module score for each set of thyroid markers
      dplyr::left_join(
        seu@meta.data %>%
          dplyr::select(seurat_clusters, dplyr::starts_with("module_"),
                        nFeature_RNA, nCount_RNA, percent.mt) %>%
          tidyr::pivot_longer(cols = -c(seurat_clusters),
                              values_to = "score") %>%
          dplyr::group_by(seurat_clusters, name) %>%
          dplyr::summarise(value = median(score)) %>%
          tidyr::pivot_wider() %>%
          janitor::clean_names()) %>%
      # reorder cols
      dplyr::select(seurat_clusters, n_cells, prop_cells, n_count_rna,
                    n_feature_rna, percent_mt, everything())
  }, file = "ct_annot_summ.rds", rerun = params$rerun)

# write to tsv
ct_annot_summ %>%
  readr::write_tsv(paste0(params$out_dir, "cluster_summary.tsv"))

knitr::kable(ct_annot_summ)
```

```{r no_celltypes, eval = is.null(params$celltypes), include = F}
knitr::knit_exit()
```

## Final celltypes

```{r final_celltypes}
cts <-
  readr::read_tsv(params$celltypes) %>%
  dplyr::mutate(seurat_clusters = as.character(seurat_clusters))
seu <-
  xfun::cache_rds({

    # add cluster celltype annotations
    seu$celltype <-
      tibble::tibble(seurat_clusters = as.character(seu$seurat_clusters)) %>%
      dplyr::left_join(cts) %>%
      dplyr::pull(celltype)

    # remove cells with no annotation
    seu <- seu[, !is.na(seu$celltype)]

    # return
    seu

  }, file = "seu_annotated.rds", rerun = params$rerun)

# plot final celltypes
DimPlot(seu, group.by = "celltype", label = TRUE) +
  NoLegend() & coord_fixed()

# plot final celltype proportions
seu@meta.data %>%
  dplyr::count(celltype) %>%
  ggplot(aes(x = reorder(celltype, -n), y = n, fill = celltype)) +
  geom_col() +
  geom_text(aes(label = n), vjust = -0.5) +
  labs(x = "celltype") +
  theme_classic() +
  theme(legend.position = "none")

# save final barcodes
writeLines(colnames(seu), paste0(params$out_dir, "annotated_cell_barcodes_10X.txt"))
colnames(seu) %>% head(10) %>%
  gsub("-1$", "", .) %>%
  chartr("ATGC", "TACG", .) %>%
  stringi::stri_reverse() %>%
  writeLines(paste0(params$out_dir, "annotated_cell_barcodes_PacBio.txt"))
```